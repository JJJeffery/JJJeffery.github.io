<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Python中使用线程的笔记</title>
      <link href="/2020/02/21/Python%E4%B8%AD%E4%BD%BF%E7%94%A8%E7%BA%BF%E7%A8%8B%E7%9A%84%E7%AC%94%E8%AE%B0/"/>
      <url>/2020/02/21/Python%E4%B8%AD%E4%BD%BF%E7%94%A8%E7%BA%BF%E7%A8%8B%E7%9A%84%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<p>Python的多线程还是蛮好用的。<br>翻开以前写的有用到线程的代码居然看不懂了…可能那会撸的代码不太规范。今晚重学一次。</p><a id="more"></a><h1 id="1-创建线程"><a href="#1-创建线程" class="headerlink" title="1. 创建线程"></a>1. 创建线程</h1><p>先 from threading import Thread</p><p>有两种方法。<br>我今晚采用的是第二种。<br>第一种新建一个类，继承Thread。<br>第二种正常新建一个函数。然后用如下方式：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">def print_1(waitTime):</span><br><span class="line">    n = 0</span><br><span class="line">    while True:</span><br><span class="line">        print(n)</span><br><span class="line">        n += 1</span><br><span class="line">        time.sleep(waitTime)</span><br><span class="line"></span><br><span class="line">thread1 = threading.Thread(target=print_1, args=(1,), name=&quot;t1&quot;)</span><br><span class="line">thread1.start()</span><br></pre></td></tr></table></figure><p>在<code>target</code>处不能直接给函数传递参数，必须用<code>args</code>，而且<code>args</code>的括号中，以<code>,</code>结尾。否则会直接执行print_1，影响其他线程运行。</p><h1 id="2-join"><a href="#2-join" class="headerlink" title="2. join"></a>2. join</h1><p>创建了两个线程，要求希望在运行完两个线程后，再执行下一步操作，比如print(“all done”)。<br>但若只用上述的方法，会立刻运行print(“all done”)，因为main是主线程，自己创建的线程是独立于这个线程运行的。<br>为此可以使用.join()的功能。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">thread1.start()</span><br><span class="line">thread2.start()</span><br><span class="line"></span><br><span class="line">thread1.join()</span><br><span class="line">thread2.join()</span><br><span class="line"></span><br><span class="line">print(&quot;all done&quot;)</span><br></pre></td></tr></table></figure><p>这样就能真的在完成所有工作后打印all done</p><h1 id="3-queue"><a href="#3-queue" class="headerlink" title="3. queue"></a>3. queue</h1><p>两个线程之间进行通信，可以使用global声明变量。<br>但现在推荐使用queue。</p><p>比如一个线程产生数据，另一个线程实时处理数据。<br>在爬虫中，一个线程用于根据网址获取内容，另一个线程用于处理这些获取的数据，即需要线程间通信。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">def getHtmlText(out_q):</span><br><span class="line">    ...</span><br><span class="line">    out_q.put(data, timeout=10)</span><br><span class="line"></span><br><span class="line">def parseHtmlText(in_q)</span><br><span class="line">    data = out_q.get(timeout=10)</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">myQueue = Queue()</span><br><span class="line"></span><br><span class="line">thread1 = Thread(target=getHtmlText, args=(myQueue,), name=&quot;t1&quot;)</span><br><span class="line">thread2 = Thread(target=parseHtmlText, args=(myQueue,), name=&quot;t2&quot;)</span><br><span class="line"></span><br><span class="line">thread1.start()</span><br><span class="line">thread2.start()</span><br><span class="line"></span><br><span class="line">thread1.join()</span><br><span class="line">thread2.join()</span><br><span class="line"></span><br><span class="line">print(&quot;all done&quot;)</span><br></pre></td></tr></table></figure><p>相较于使用global，Queue本身就是搭配多线程使用的，因此自带锁机制，而且可以设置阻塞时间（若没设置阻塞时间，将一直阻塞）。从而可以避免多线程中数据操作的混乱。</p><p>否则，若是没额外搭配线程的锁机制，那么比如两个线程，一个是写入111111，另一个是写入222222，你以为他最终结果是111111222222或者222222111111，但实际上很可能是12221112212这样的乱码。</p><p>建议搭配栈等数据结构使用Queue。</p><h1 id="4-Lock"><a href="#4-Lock" class="headerlink" title="4. Lock"></a>4. Lock</h1><p>如果只是进行线程间的通信，那么Queue可以很好的解决。<br>但若还要进行IO打印之类的对外界通信，那么Queue可能就没办法了，这时候还是要请出线程的锁。</p><p>比如这样一段代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">def print_time():</span><br><span class="line">    while True:</span><br><span class="line">        timeNow = time.localtime(time.time())</span><br><span class="line">        print(timeNow)</span><br><span class="line">        print(&quot;--------------------&quot;)</span><br><span class="line">        print(&quot;--------------------&quot;)</span><br><span class="line">        print(&quot;--------------------&quot;)</span><br><span class="line">    </span><br><span class="line">thread3 = threading.Thread(target=print_time, name=&quot;t3&quot;)</span><br><span class="line">thread4 = threading.Thread(target=print_time, name=&quot;t4&quot;)</span><br><span class="line">thread5 = threading.Thread(target=print_time, name=&quot;t5&quot;)</span><br><span class="line">thread3.start()</span><br><span class="line">thread4.start()</span><br><span class="line">thread5.start()</span><br></pre></td></tr></table></figure><p>运行正常的结果应该是输出一行时间后，跟着三行虚线，但实际运行起来可能就乱七八糟了。<br>这时候请出我们的锁。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">def print_time():</span><br><span class="line">    while True:</span><br><span class="line">        timeNow = time.localtime(time.time())</span><br><span class="line">        with myLock:</span><br><span class="line">            print(timeNow)</span><br><span class="line">            print(&quot;--------------------&quot;)</span><br><span class="line">            print(&quot;--------------------&quot;)</span><br><span class="line">            print(&quot;--------------------&quot;)</span><br><span class="line"></span><br><span class="line">myLock = threading.Lock()</span><br><span class="line">thread3 = threading.Thread(target=print_time, name=&quot;t3&quot;)</span><br><span class="line">thread4 = threading.Thread(target=print_time, name=&quot;t4&quot;)</span><br><span class="line">thread5 = threading.Thread(target=print_time, name=&quot;t5&quot;)</span><br><span class="line">thread3.start()</span><br><span class="line">thread4.start()</span><br><span class="line">thread5.start()</span><br></pre></td></tr></table></figure><p>这时，打印出来的就是每一行时间都跟着三条虚线了。<br>注意，必须所有线程公用一个锁，所以要提前创建一个锁。并且不用声明myLock为global，因为在这里，我们不对myLock进行修改。</p>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
            <tag> 笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python中使用迭代器的笔记</title>
      <link href="/2020/02/20/Python%E4%B8%AD%E4%BD%BF%E7%94%A8%E8%BF%AD%E4%BB%A3%E5%99%A8%E7%9A%84%E7%AC%94%E8%AE%B0/"/>
      <url>/2020/02/20/Python%E4%B8%AD%E4%BD%BF%E7%94%A8%E8%BF%AD%E4%BB%A3%E5%99%A8%E7%9A%84%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<blockquote><p>今晚在看生成器，貌似在多次循环中可以节省内存。</p></blockquote><a id="more"></a><h1 id="1-构造方法"><a href="#1-构造方法" class="headerlink" title="1. 构造方法"></a>1. 构造方法</h1><p>将原本该返回list的，改为返回单个元素，<br>并在构造函数的时候，将<code>return</code>换为<code>yield</code>。</p><p>若需要生成有限个，在构造函数的时候使用如下方法</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">n = 0</span><br><span class="line">while n &lt; max_value:</span><br><span class="line">    yield n</span><br><span class="line">    n += 1</span><br></pre></td></tr></table></figure><p>若需要生成无限个，在构造函数的时候使用如下方法</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">n = 0</span><br><span class="line">while True:</span><br><span class="line">    yield n</span><br><span class="line">    n += 1</span><br></pre></td></tr></table></figure><h1 id="2-原理"><a href="#2-原理" class="headerlink" title="2. 原理"></a>2. 原理</h1><p>与普通的直接完整生成一个List不同，含yield的函数访问一次只生成一个元素并返回。<br>构造的生成器函数内有循环，每次访问，运行到yield所在的行后即停止。</p><h1 id="3-使用方法"><a href="#3-使用方法" class="headerlink" title="3. 使用方法"></a>3. 使用方法</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">for i in gen(5):</span><br><span class="line">    print(i)</span><br><span class="line"></span><br><span class="line"># 输出结果</span><br><span class="line">0</span><br><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td></tr></table></figure><p>或</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">myGen = gen(5)</span><br><span class="line">next(myGen)</span><br><span class="line">next(myGen)</span><br><span class="line">next(myGen)</span><br><span class="line">next(myGen)</span><br><span class="line">next(myGen)</span><br><span class="line"># 输出结果</span><br><span class="line">0</span><br><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td></tr></table></figure><h1 id="4-注意"><a href="#4-注意" class="headerlink" title="4. 注意"></a>4. 注意</h1><ul><li><p>有的地方在教生成器的时候，还在用<code>myGen.next()</code>的方法，在新版Python中已换为函数式<code>next(myGen)</code></p></li><li><p>老教材中说，常用用的<code>for i in range(value)</code>，若value值比较大，可能会造成内存浪费，推荐使用生成器xrange的方法，但在新版Python中，已经没有xrange了，xrange的特性已经集成到range中了，也就是说range(10)和range(10000)都不会造成内存浪费</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
            <tag> 笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>使用Java编写仿真程序的学习笔记-1</title>
      <link href="/2020/02/09/%E4%BD%BF%E7%94%A8Java%E7%BC%96%E5%86%99%E4%BB%BF%E7%9C%9F%E7%A8%8B%E5%BA%8F%E7%9A%84%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
      <url>/2020/02/09/%E4%BD%BF%E7%94%A8Java%E7%BC%96%E5%86%99%E4%BB%BF%E7%9C%9F%E7%A8%8B%E5%BA%8F%E7%9A%84%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<blockquote><p>在B站看到一个视频<a href="https://www.bilibili.com/video/av86478875/" target="_blank" rel="noopener">《计算机仿真程序告诉你为什么现在还没到出门的时候！！！》</a>。<br>使用Java编写仿真程序，模拟疫情传播。<br>学习了许多，做个笔记。</p></blockquote><a id="more"></a><p>源码也已经在Github发布，有兴趣的戳<a href="https://github.com/KikiLetGo/VirusBroadcast" target="_blank" rel="noopener">这里</a>clone。</p><h1 id="1-getInstance"><a href="#1-getInstance" class="headerlink" title="1. getInstance"></a>1. getInstance</h1><p>Java中，一般使用<code>new + 类</code>的方法创建对象。这种可以创建任意数量的对象，且各自独立。</p><p>但在Java仿真模拟中，如果多个class，即多个java程序需要对同一个对象（本例中是全部的Person对象组成的PersonPool这个对象）进行多次操作，可以使用getInstance的方法得到这个唯一恒定对象。</p><p>该方法优点及使用场景：</p><ul><li>全部程序使用同一个对象，避免操作对象选择错误</li><li>对象的定义过程在类的定义过程确定，仿真过程的定义和使用过程完全独立</li><li>基础对象的定义过程，可以与“该对象组合形成的新对象”进行交互（即在定义<code>人</code>的时候，可以定义<code>人</code>与<code>社会</code>进行交互的操作）</li><li>使用场景：仿真程序中，个体形成的整体，可以使用</li></ul><h1 id="2-Constants程序"><a href="#2-Constants程序" class="headerlink" title="2. Constants程序"></a>2. Constants程序</h1><p>该程序没有定义任何操作，只定义了常数。<br>该方法优点：</p><ul><li>可以把与模拟有关的常量提取出来，其他程序使用的时候使用Constants.常量名的方法访问</li><li>验证不同常量对仿真结果的影响时，便于修改常量</li></ul><h1 id="3-可视化"><a href="#3-可视化" class="headerlink" title="3. 可视化"></a>3. 可视化</h1><p>main文件中：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">var p = new MyPanel();</span><br><span class="line">var panelThread = new Thread(p);</span><br><span class="line">var frame = new JFrame(&quot;疫情模拟&quot;);</span><br><span class="line"></span><br><span class="line">frame.add(p);</span><br><span class="line">frame.setSize(1000, 800);</span><br><span class="line">frame.setLocationRelativeTo(null);</span><br><span class="line">frame.setVisible(true);</span><br><span class="line">frame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);</span><br><span class="line">panelThread.start();</span><br></pre></td></tr></table></figure><p>这样可以以windows视窗的形式展示仿真过程及结果。</p><p>MyPanel文件中：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">public class MyPanel extends JPanel implements Runnable</span><br></pre></td></tr></table></figure><p>MyPanel继承自JPanel父类及Runnable的接口。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public MyPanel() &#123;</span><br><span class="line">    this.setBackground(new Color(0x444444));</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>设置窗口背景颜色。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">    public void run() &#123;</span><br><span class="line">        while (true) &#123;</span><br><span class="line">            this.repaint();</span><br><span class="line"></span><br><span class="line">            try &#123;</span><br><span class="line">                Thread.sleep(100);</span><br><span class="line">                System.out.println(worldTime);</span><br><span class="line">                worldTime++;</span><br><span class="line">            &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>设置窗口更新，worldTime是本次仿真中代表时间流逝的变量，一般仿真都会用到。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">    public void paint(Graphics arg0) &#123;</span><br><span class="line">        super.paint(arg0);</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>可以理解为，窗口显示的每一帧，显示什么内容。<br>使用<code>arg0.</code>的方法，为每一帧添加内容。<br>先为arg0.setColor，然后使用arg0.drawRect等功能，即可描绘内容<br>若在此操作中有使用到与时间有关的操作，建议新建一个时间参数，仅在此函数中自加，不要使用worldTime。在实践中一般难以捕捉到worldTime为特定值的时候。可能与多线程有关。</p><h1 id="4-static"><a href="#4-static" class="headerlink" title="4. static"></a>4. static</h1><p>定义静止的变量或函数操作。即使没有实例化某一个类，也可以直接通过<code>类名.变量</code>的方法访问。<br>不同于final，final之后该变量不可改，但static可以改，只是这个变量与类共存，而不依赖于某个对象存在。</p><p>使用场景：</p><ul><li>对于一个类的所有实例，该变量总是一样，而且这个类可能会变</li></ul>]]></content>
      
      
      <categories>
          
          <category> 编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 编程 </tag>
            
            <tag> 仿真 </tag>
            
            <tag> Java </tag>
            
            <tag> 学习笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>一些你想耍流氓时，能帮你优雅一点的工具</title>
      <link href="/2019/11/30/%E4%B8%80%E4%BA%9B%E4%BD%A0%E6%83%B3%E8%80%8D%E6%B5%81%E6%B0%93%E6%97%B6%EF%BC%8C%E8%83%BD%E5%B8%AE%E4%BD%A0%E4%BC%98%E9%9B%85%E4%B8%80%E7%82%B9%E7%9A%84%E5%B7%A5%E5%85%B7/"/>
      <url>/2019/11/30/%E4%B8%80%E4%BA%9B%E4%BD%A0%E6%83%B3%E8%80%8D%E6%B5%81%E6%B0%93%E6%97%B6%EF%BC%8C%E8%83%BD%E5%B8%AE%E4%BD%A0%E4%BC%98%E9%9B%85%E4%B8%80%E7%82%B9%E7%9A%84%E5%B7%A5%E5%85%B7/</url>
      
        <content type="html"><![CDATA[<blockquote><p>工具工具工具！</p></blockquote><a id="more"></a><h2 id="新浪微热点"><a href="#新浪微热点" class="headerlink" title="新浪微热点 "></a><a href="http://www.wrd.cn/" target="_blank" rel="noopener">新浪微热点 </a></h2><p>提供全网热度<br>提供全网关键词词云</p><h2 id="极其厉害的抠图工具"><a href="#极其厉害的抠图工具" class="headerlink" title="极其厉害的抠图工具"></a><a href="https://www.remove.bg/zh" target="_blank" rel="noopener">极其厉害的抠图工具</a></h2><p>人物抠图十分好用<br>可以在线使用，也可以利用Python，使用他们的API</p>]]></content>
      
      
      <categories>
          
          <category> Help </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 工具 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据可视化-动态柱状图</title>
      <link href="/2019/11/21/%E6%95%B0%E6%8D%AE%E5%8F%AF%E8%A7%86%E5%8C%96-%E5%8A%A8%E6%80%81%E6%9F%B1%E7%8A%B6%E5%9B%BE/"/>
      <url>/2019/11/21/%E6%95%B0%E6%8D%AE%E5%8F%AF%E8%A7%86%E5%8C%96-%E5%8A%A8%E6%80%81%E6%9F%B1%E7%8A%B6%E5%9B%BE/</url>
      
        <content type="html"><![CDATA[<blockquote><p>就是可以看中国GDP噌噌噌往上涨的那种动态柱状图~</p></blockquote><a id="more"></a><p>虽然除了看房价噌噌噌往上涨，暂时也想不到能怎么玩。</p><p>但是确实很好看，那就拿来玩玩了。</p><p>特别鸣谢<a href="https://github.com/Jannchie/Historical-ranking-data-visualization-based-on-d3.js.git" target="_blank" rel="noopener">见齐</a>大佬免费开源他的框架。</p><h1 id="数据准备"><a href="#数据准备" class="headerlink" title="数据准备"></a>数据准备</h1><p>原生框架使用.csv文件，并且格式有点反人类……<br>如下：<br><img src="http://q0zymd4jt.bkt.clouddn.com/csv%E6%A0%BC%E5%BC%8F.jpg" alt=".csv文件中的规范数据格式"></p><p>不敢乱改原生框架，所以写了个小工具，利用.xlsx文件来生成规范的.csv文件。</p><p>代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">import xlrd</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def Save2Local(statistics, root, jud = 0):</span><br><span class="line">    with open(root, &apos;a&apos;, encoding=&apos;utf-8&apos;) as f:</span><br><span class="line">        if jud == 0:</span><br><span class="line">            f.write(str(statistics) + &apos;\n&apos;)</span><br><span class="line">        elif jud == 1:</span><br><span class="line">            f.write(str(statistics) + &apos;\t&apos;)</span><br><span class="line">        else:</span><br><span class="line">            f.write(str(statistics))</span><br><span class="line">        f.close()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class Formal2Csv(object):</span><br><span class="line">    def file_load(self, file_name):</span><br><span class="line">        data_col = []</span><br><span class="line">        workbook = xlrd.open_workbook(file_name)</span><br><span class="line">        table = workbook.sheets()[0]</span><br><span class="line">        for row in range(table.nrows):</span><br><span class="line">            data_col.append(table.row_values(row))</span><br><span class="line">        self.data = data_col</span><br><span class="line">        return data_col</span><br><span class="line"></span><br><span class="line">    def formalcsv(self, output_file_name):</span><br><span class="line">        date0 = self.data[0][1:]</span><br><span class="line">        title = &quot;name,type,value,date&quot;</span><br><span class="line">        Save2Local(title, output_file_name)</span><br><span class="line">        for data_line in self.data[1:]:</span><br><span class="line">            item_name = data_line[0]</span><br><span class="line">            num = 0</span><br><span class="line">            for item_data in data_line[1:]:</span><br><span class="line">                Save2Local(str(item_name) + &quot;,&quot; + &quot;&quot; + &quot;,&quot; +str(item_data) + &quot;,&quot; + str(date0[num]), output_file_name)</span><br><span class="line">                num += 1</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">if __name__ == &apos;__main__&apos;:</span><br><span class="line">    file_name = &quot;city_data.xlsx&quot;</span><br><span class="line">    output_file_name = &quot;city_data.csv&quot;</span><br><span class="line">    pre_data = Formal2Csv()</span><br><span class="line">    pre_data.file_load(file_name)</span><br><span class="line">    pre_data.formalcsv(output_file_name)</span><br></pre></td></tr></table></figure><p>原数据必须为.xlsx文件，如果是.xls就用正经的Excel另存为.xlsx，千万别手动更改后缀名，否则会造成奇奇怪怪的后果。<br>.xlsx文件中的数据格式也得存储为如下格式：</p><p><img src="http://q0zymd4jt.bkt.clouddn.com/xlsx%E6%A0%BC%E5%BC%8F.jpg" alt=".xlsx文件中的数据格式"></p><p>然后再在上面列出的代码中，修改file_name和outpur_file_name就可以了。</p><p>如果Python生成的.CSV文件中，日期是一堆奇怪的数值，那就在.xlsx，将日期的格式，由<code>日期</code>改为<code>常规</code>即可。</p><h1 id="历史数据排名可视化"><a href="#历史数据排名可视化" class="headerlink" title="历史数据排名可视化"></a>历史数据排名可视化</h1><p>首先需要下载由<a href="https://github.com/Jannchie/Historical-ranking-data-visualization-based-on-d3.js.git" target="_blank" rel="noopener">见齐</a>大佬提供的框架，也可以下载<a href="http://q0zymd4jt.bkt.clouddn.com/%E5%8E%86%E5%8F%B2%E6%95%B0%E6%8D%AE%E5%8F%AF%E8%A7%86%E5%8C%96.zip" target="_blank" rel="noopener">我</a>提供的修改过一些参数的版本（不分type，每页展示十条，内含2002-2017国内主要城市房价变化示例数据）</p><blockquote><p><strong>一句话用法</strong><br>只需打开src目录下的bargraph.html。然后点击页面中间的选择文件按钮，接着选择csv格式的数据文件，便可以看到可视化的结果。<br>对展示形式有其他要求的，可以用记事本/VS Code打开_config.js文件进行修改。</p></blockquote><h1 id="发布"><a href="#发布" class="headerlink" title="发布"></a>发布</h1><p>原框架仅支持在本地选择数据，然后现场展示，对发布的支持不是特别好。因此推荐使用录屏软件录屏后发布。</p>]]></content>
      
      
      <categories>
          
          <category> 可视化 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
            <tag> 编程 </tag>
            
            <tag> 工具 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>当你第一次打开时或许你可以看一下</title>
      <link href="/2019/11/21/%E5%BD%93%E4%BD%A0%E7%AC%AC%E4%B8%80%E6%AC%A1%E6%89%93%E5%BC%80%E6%97%B6%E6%88%96%E8%AE%B8%E4%BD%A0%E5%8F%AF%E4%BB%A5%E7%9C%8B%E4%B8%80%E4%B8%8B/"/>
      <url>/2019/11/21/%E5%BD%93%E4%BD%A0%E7%AC%AC%E4%B8%80%E6%AC%A1%E6%89%93%E5%BC%80%E6%97%B6%E6%88%96%E8%AE%B8%E4%BD%A0%E5%8F%AF%E4%BB%A5%E7%9C%8B%E4%B8%80%E4%B8%8B/</url>
      
        <content type="html"><![CDATA[<blockquote><p>希望你用电脑<br>用谷歌浏览器</p></blockquote><a id="more"></a><ul><li><p>如果你用手机打开，你可能会看不到随机乱跑的线条</p></li><li><p>如果你用Edge打开，你可能会看不到我精心画的纸飞机鼠标</p></li><li><p>如果哪天你在国内打不开了，那是腾讯云炸了；换国外IP访问，或者喊我一声</p></li><li><p>如果你要留言，希望你可以留下你的昵称</p></li><li><p>如果你要分享，每篇文章下面会有个分享按钮，也可以直接用微信打开分享</p></li><li><p>如果打开很慢，那是我优化不够，加载的插件比较多，但是我并不想继续优化</p></li><li><p>有两只皮卡丘，和一个小可爱</p></li><li><p>有一只皮卡丘会摇尾巴和动耳朵，希望你耐心等待加载</p></li></ul>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>关于爬虫的两个得力工具</title>
      <link href="/2019/11/15/%E5%85%B3%E4%BA%8E%E7%88%AC%E8%99%AB%E7%9A%84%E4%B8%A4%E4%B8%AA%E5%BE%97%E5%8A%9B%E5%B7%A5%E5%85%B7/"/>
      <url>/2019/11/15/%E5%85%B3%E4%BA%8E%E7%88%AC%E8%99%AB%E7%9A%84%E4%B8%A4%E4%B8%AA%E5%BE%97%E5%8A%9B%E5%B7%A5%E5%85%B7/</url>
      
        <content type="html"><![CDATA[<blockquote><p>今天与某在北京造超导核弹的<a href="https://camusecao.top" target="_blank" rel="noopener">小流氓</a>聊及爬虫的时候，发现他被反爬了。</p><p>我没有笑。</p><p>后来想起自己刚学爬虫的时候也曾被一些简单的反爬机制制裁过，索性就把我的祖传代码贴出来，供大家参考交流。对于初学者也可以直接复制使用。</p><p>当然我也是个初学者。</p></blockquote><a id="more"></a><h2 id="get-html-text-url"><a href="#get-html-text-url" class="headerlink" title="get_html_text(url)"></a>get_html_text(url)</h2><p>这是我每只爬虫的第一步，几行非常简单的代码，但也修修补补了好几回才成为今天最顺手的一个工具。</p><p>这也应该是我写的第一段正经工作代码，陪着我撸过无数个网页，测试了无数次。</p><p>可靠性 += 1</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">import requests</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def get_html_text(url):</span><br><span class="line">    try:</span><br><span class="line">        kv = &#123;&apos;User-Agent&apos;: &apos;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) &apos;</span><br><span class="line">                            &apos;Chrome/64.0.3282.140 Safari/537.36 Edge/17.17134&apos;&#125;</span><br><span class="line">        r = requests.get(url, headers=kv, timeout=30)</span><br><span class="line">        r.raise_for_status()</span><br><span class="line">        r.encoding = r.apparent_encoding</span><br><span class="line">        return r.text</span><br><span class="line">    except:</span><br><span class="line">        return &quot;&quot;</span><br></pre></td></tr></table></figure><h3 id="用法"><a href="#用法" class="headerlink" title="用法"></a>用法</h3><p># kv 模拟正常使用浏览器打开网页时，浏览器自动向网站服务器发送的headers，以此应对网站最基本的反爬机制</p><p># 一般来说，只要不是恶意攻击，或者点击速度过快，或者持续点击同一个页面，此方法足以因对大部分网站</p><p># timeout 30s内打不开网页即当做该网页无响应，避免爬虫程序卡在某一步</p><p># 正常打开的网页，本函数返回html</p><p># 无法打开的网页或响应超时的网页，本函数返回为空</p><p>使用时，将网址以文本形式(<em>就是用两个英文引号”括起来，并且一定要加上<code>http://</code>，平时自己使用浏览器时可以不用加，但爬虫程序并不会帮你加</em>)作为参数输入get_html_text(url)</p><h2 id="time-sleep"><a href="#time-sleep" class="headerlink" title="time.sleep()"></a>time.sleep()</h2><p>当你要爬携程、美团这两家的网站的时候，请<strong>千万千万千万</strong>用上这个函数！！！</p><p>来自一个被携程和美团双双封过的人的忠告！</p><p>哪一步都可以省，这一步千万不能省！！</p><p>否则你就会体验到，你连正常的打开美团想买个套餐都不行的滋味。</p><p>显然正经的爬虫应该在任何时候都加这一句。</p><h3 id="用法-1"><a href="#用法-1" class="headerlink" title="用法"></a>用法</h3><p>当你使用for语句时，在for循环的最后一行写上这函数，需要提前 <code>import time</code>，这是Python自带的一个库，不用另外安装。</p><p>括号内写上sleep的时间，以秒为单位。</p><h3 id="另外"><a href="#另外" class="headerlink" title="另外"></a>另外</h3><p>如果你问我，这个世界上有没有一个网站我可以全力爬取，不用sleep。</p><p>那我只能回答你，有。</p><p>如果你问我，那你可以不可以告诉我这个网站。</p><p>那我也只能回答你，可以。</p><p>如果你问我，那你为什么不告诉我。</p><p>那样我就只能告诉你了：</p><p>所有以<code>xmu.edu.cn</code>结尾的网站，你随便爬，一只不够放两只，单线程不够你就多线程，唯一能限制你的应该是vpn的速度。</p><p>不过你没事干啥要去爬这个网站呢？</p><p>还有一个网站也是不限制的，但我这边不能说。</p><p>说了我号可能就没了。</p>]]></content>
      
      
      <categories>
          
          <category> 编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
            <tag> 编程 </tag>
            
            <tag> 爬虫 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
    
    
    <entry>
      <title>Something more about J.F. Chen</title>
      <link href="/about/index.html"/>
      <url>/about/index.html</url>
      
        <content type="html"><![CDATA[<ul><li><strong>洋文名：</strong> 并没有正式的英文名， 暂时JJJeff吧</li><li><strong>所在地：</strong> 福建 厦门</li><li><strong>职业：</strong> <code>前物理学院学生</code>、<code>现MPAcc学生</code></li><li><strong>喜欢的食物：</strong> 这本菜单上的全部东西</li><li><strong>常用编程语言：</strong> <code>Python</code>、<code>Matlab</code>、<code>(朋友你听过51单片机的汇编语言吗？）</code>、<code>MySQL</code>、<code>Java</code></li><li><strong>兴趣爱好：</strong> 躺着、靠着、给个桌子我也能趴着；平时wzry上上分，关注LOL；小概率隔天跑跑步，以前肯踢足球，现在没鞋了；不想学习时撸两行代码也很快乐</li><li><strong>近期计划：</strong> 求求你让我过了CPA吧</li><li><strong>想学：</strong> <code>Econometrics</code>、<code>建模</code>、<code>统计</code></li><li><strong>想做：</strong> 去成都看大熊猫、去西安看十三朝古都、去潮汕吃火锅、去内蒙古看草原，套马杆也想…</li><li><strong>想吃：</strong> <code>.+</code>（这是一个神奇的正则表达式）</li><li><strong>想说：</strong> 上分喊我、学习喊我、吃饭喊我</li></ul><p>其实我还想说：夏天这么可爱，我想请它吃个饭。如果你有空，你也可以来。</p><p>虽然现在已经到了早晨穿两件都不太够的季节了，但我说这句话的意思就是：<strong>你可以举着勺子开心地跑过来了</strong>。</p>]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>Categories</title>
      <link href="/categories/index.html"/>
      <url>/categories/index.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>commonweal</title>
      <link href="/commonweal/index.html"/>
      <url>/commonweal/index.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>Tags</title>
      <link href="/tags/index.html"/>
      <url>/tags/index.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
    </entry>
    
    
  
</search>
