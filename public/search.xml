<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>跨数据库查询小记</title>
      <link href="/2020/06/18/%E8%B7%A8%E6%95%B0%E6%8D%AE%E5%BA%93%E6%9F%A5%E8%AF%A2%E5%B0%8F%E8%AE%B0/"/>
      <url>/2020/06/18/%E8%B7%A8%E6%95%B0%E6%8D%AE%E5%BA%93%E6%9F%A5%E8%AF%A2%E5%B0%8F%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<p>作为一个熟练掌握了如何构建联表查询的人<br>今天差点被跨数据库查询捶翻在地</p><a id="more"></a><p>正经人家一般也不会跨数据库查询。</p><p>但我今天就碰上了，一波数据非要分两次给。<br>于是就分成两个数据库了。</p><p>于是我就按我熟悉的方式，试图一次性搜索到合适的语句。</p><h1 id="ATTACH加分号"><a href="#ATTACH加分号" class="headerlink" title="ATTACH加分号"></a>ATTACH加分号</h1><p>关键语句如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ATTACH DATABASE &apos;C:\Users\Chen\Desktop\ANN_STO\TradeData.db&apos; AS &apos;TradeData&apos;</span><br></pre></td></tr></table></figure><p>后续跟上SELECT语句。</p><p>但这样他就总提示<code>near &quot;SELECT&quot;: syntax error</code>。</p><p>我还以为是我单词拼写错误，还专门查了一下字典（虽然这是自动补全的）。</p><p>后来看了一下别人的代码，好像ATTACH语句后都要加上分号。</p><p>于是我试了一下，才发现，如果加分号的话，SQL语句是分块依次运行的。</p><p>再联想到普通SQL语句那种乱七八糟的逻辑，按我理解，就是如果没有加分号，ATTACH是不一定先运行，那么在SELECT中，就未必找得到这个表了。</p><p>所以，<strong>ATTACH必须加分号！</strong></p><h1 id="多次运行加DETACH"><a href="#多次运行加DETACH" class="headerlink" title="多次运行加DETACH"></a>多次运行加DETACH</h1><p>解决完第一个问题，结果还是不行。提示<code>database TradeData is already in use</code>。</p><p>？？？</p><p>我占用了？</p><p>我还以为我占用了数据库，还把所有可能占用数据库的都关了，结果还是这样？</p><p>又是多方查证，才知道还有DETACH。</p><p>经过ATTACH，我自己定义的别名<code>AS &#39;TradeData&#39;</code>已经被占用。他提示的占用是这个占用，而DETACH则是解除这个占用。</p><p>上一次运行ATTACH就已经占用了别名，当我修改后想再次运行，相当于也要再次占用，但数据库不肯让我简单的覆盖，于是报错。</p><p>所以只能用DETACH解除占用后再导入。</p><p>同样的，DETACH语句也得加分号。</p><hr><p>最近摸到了一个项目，感受到这个世界怎么有这么多厉害的人，而且这群人还不是最顶尖的。<br>这让人很难过。<br>于是只能狂撸代码。</p><p>这个月写的代码可能和去年一整年的差不多。</p><p>不够撸完代码发现，原来他们讲的头头是道的东西，我也做出来了。甚至他们的难点，我也顺手捶翻了。<br>于是我又快乐了。</p><p>嘿！明天来个SevenBus.</p>]]></content>
      
      
      <categories>
          
          <category> MySQL </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MySQL </tag>
            
            <tag> 笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python中使用递归算法和yield from的笔记</title>
      <link href="/2020/03/01/Python%E4%B8%AD%E4%BD%BF%E7%94%A8%E9%80%92%E5%BD%92%E7%AE%97%E6%B3%95%E5%92%8Cyield%20from%E7%9A%84%E7%AC%94%E8%AE%B0/"/>
      <url>/2020/03/01/Python%E4%B8%AD%E4%BD%BF%E7%94%A8%E9%80%92%E5%BD%92%E7%AE%97%E6%B3%95%E5%92%8Cyield%20from%E7%9A%84%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<blockquote><p>今晚是连跪的一晚。<br>看看神仙代码吧。</p></blockquote><a id="more"></a><h1 id="前情介绍"><a href="#前情介绍" class="headerlink" title="前情介绍"></a>前情介绍</h1><p>好不容易找到一个盗版书籍的PDF资源，下载完解压开来发现是还有一个加密了的压缩包，以及一个txt文件，说要钱。</p><p>怒了，用Python写个暴力破解加密Zip文件的程序！</p><h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><p>思路不难，不多说，主要怎么构建密码。</p><p>用正常的思路，先构建一个密码的字符集，比如<code>[0,1,2,3,4,5,6,7,8,9]</code>。</p><p>接下来，若是一个五位数密码，搭建五层for循环，在上述的字符集里遍历五次，就能生成所有的由这个字符集组成的密码了。</p><p>要想节省内存，还可以用上最受人喜爱的<code>yield</code>.</p><p>然而问题在于，我并不知道密码是几位数啊……….哪怕按常理来说，一般密码是8位或9位，但即使我知道只有这两种情况，按照上面的方法，那我也要构建两个分支，一个8层for循环，一个9层？？？</p><p>这可真是太愚蠢了。</p><h1 id="神仙代码来了"><a href="#神仙代码来了" class="headerlink" title="神仙代码来了"></a>神仙代码来了</h1><p>还好通网了。</p><p>找到了这么一串代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">from typing import List</span><br><span class="line"></span><br><span class="line">dictionaries = [chr(i) for i in</span><br><span class="line">                chain(range(97, 123),    # a - z</span><br><span class="line">                      range(65, 91),    # A - Z</span><br><span class="line">                      range(48, 58))]    # 0 - 9</span><br><span class="line"></span><br><span class="line">def all_passwd(dictionaries: List[str], maxlen: int):</span><br><span class="line">    # 返回由 dictinaries 中字符组成的所有长度为 maxlen 的字符串</span><br><span class="line"></span><br><span class="line">    def helper(temp: list, start: int, n: int):</span><br><span class="line">        # 辅助函数，是个生成器</span><br><span class="line">        if start == n:    # 达到递归出口</span><br><span class="line">            yield &apos;&apos;.join(temp)</span><br><span class="line">            return</span><br><span class="line">        for t in dictionaries:</span><br><span class="line">            temp[start] = t    # 在每个位置</span><br><span class="line">            yield from helper(temp, start + 1, n)</span><br><span class="line"></span><br><span class="line">    yield from helper([0] * maxlen, 0, maxlen)</span><br></pre></td></tr></table></figure><h2 id="yield-from"><a href="#yield-from" class="headerlink" title="yield from"></a>yield from</h2><p>首先是<code>yield from</code>。</p><p>这个用在生成器的函数中，后面跟一个可迭代对象。</p><p>本质上就是把可迭代对象里的元素一个一个yield出来。</p><p>下面两段代码等同。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">dic = (str(i) for i in range(10))</span><br><span class="line"></span><br><span class="line">def get_str_1():</span><br><span class="line">    for i in dic:</span><br><span class="line">        yield i</span><br><span class="line"></span><br><span class="line">def get_str_2():</span><br><span class="line">    yield from dic</span><br></pre></td></tr></table></figure><p>过。</p><h2 id="递归算法"><a href="#递归算法" class="headerlink" title="递归算法"></a>递归算法</h2><p>接下来看递归。</p><p>我理解的递归算法，是自己调用自己。</p><p>第一次接触递归，是在算斐波拉契数列的时候。</p><p>今晚再次见面，差点认不出来。</p><p>我的理解开始：</p><p>主体在于helper函数。</p><p>首先传入长度为max_length的全0列表。<br>start数为0，end数为max_length。</p><p>主函数main对这个的helper函数的第一次调用，这个helper实际是循环调用了自己max_length次，即创建了对dictionaries进行了max_length次便利的for循环。</p><p>而且原本传进去的列表参数是全0，但第一次循环过后，变成了全a。</p><p>在最后一层循环里，<code>yield from helper(temp, start + 1, n)</code>这一句中，start + 1 =n了，因此最后一层循环在对temp列表的最后一个元素进行赋值/更改后，调用的helper函数，在if判断里因为<code>start == n</code>，所以会yield出来。</p><p>yield然后有一句return语句，这样下次迭代时从这开始。</p><p>主函数main对这个的helper函数的第二次调用，从return开始，这样即可以回到第上一层for循环里，即最后一层for循环里，根据最后一层的for继续遍历dictionaries，选择dictionaries里的下一个字符，赋值给最后temp的最后一位，然后调用helper并yield出去。</p><p>这样就能完成密码最后一位的变化。</p><p>当最后一位变化完一边之后，最后一层的for循环也结束，就回到倒数第二层for循环进行遍历。</p><p>其他层同理。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ul><li><p>使用递归算法，可以将for循环的层数变成函数的一个参数，不用写重复的代码。配合yield from，可以省下大量内存。</p></li><li><p>搭配一个递归的出口，以判断传入的某一个参数是否等于某个特定值，若达到条件则yield + return.</p></li><li><p>循环的嵌套，以调用函数自身，并且传入的某一个参数是+1/-1这种方式。</p></li><li><p>本例中是一次循环生成一个结果并输出；但在计算斐波拉契数列的值时，求解下一个值，其实只是求上一个值得步骤+求上上个值的步骤+一个额外步骤，即存在大量的重复计算，此时应当考虑存储每一次计算的结果，供后续计算查询，以节省时间。</p></li></ul><h1 id="练手"><a href="#练手" class="headerlink" title="练手"></a>练手</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line">import random</span><br><span class="line"></span><br><span class="line">&apos;&apos;&apos;</span><br><span class="line">冒泡算法</span><br><span class="line">由于Python中递归层数限制</span><br><span class="line">排序的数字最多为997个</span><br><span class="line">&apos;&apos;&apos;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def bubble(my_list):</span><br><span class="line">    my_length = len(my_list)</span><br><span class="line"></span><br><span class="line">    if my_length == 1:</span><br><span class="line">        yield my_list[-1]</span><br><span class="line">        return  # 递归出口</span><br><span class="line"></span><br><span class="line">    for i in range(my_length - 1):</span><br><span class="line">        former = my_list[i]</span><br><span class="line">        latter = my_list[i + 1]</span><br><span class="line"></span><br><span class="line">        if former &gt; latter:</span><br><span class="line">            my_list[i] = latter</span><br><span class="line">            my_list[i + 1] = former</span><br><span class="line">        else:</span><br><span class="line">            pass</span><br><span class="line"></span><br><span class="line">    yield from bubble(my_list[:-1])  # 递归调用的函数本质是个迭代器，必须使用yield from才能正确进入递归</span><br><span class="line"></span><br><span class="line">    yield my_list[-1]  # 每个递归函数中输出最后一个数，即最大值</span><br><span class="line">    return</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&apos;&apos;&apos;</span><br><span class="line">选择排序</span><br><span class="line">这边对数组使用了remove的操作</span><br><span class="line">这种操作仅对数组进行了操作，并且返回为None</span><br><span class="line">所以若使用 c = a.rempve(1)</span><br><span class="line">c将变成None</span><br><span class="line">因此不用设置中间变量c</span><br><span class="line">若要使用也是</span><br><span class="line">a.rempve(1)</span><br><span class="line">c = a</span><br><span class="line">&apos;&apos;&apos;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def selection(my_list):</span><br><span class="line">    my_length = len(my_list)</span><br><span class="line">    max_num = my_list[0]</span><br><span class="line"></span><br><span class="line">    if my_length == 1:</span><br><span class="line">        yield max_num</span><br><span class="line">        return</span><br><span class="line"></span><br><span class="line">    for i in range(1, my_length):</span><br><span class="line">        max_num = my_list[i] if max_num &lt; my_list[i] else max_num</span><br><span class="line"></span><br><span class="line">    my_list.remove(max_num)</span><br><span class="line"></span><br><span class="line">    yield from selection(my_list)</span><br><span class="line"></span><br><span class="line">    yield max_num</span><br><span class="line">    return</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">if __name__ == &quot;__main__&quot;:</span><br><span class="line">    myList = []</span><br><span class="line">    for _ in range(500):</span><br><span class="line">        myList.append(random.randint(0, 1000))</span><br><span class="line">    print(myList)</span><br><span class="line"></span><br><span class="line">    a = bubble(myList)</span><br><span class="line">    b = selection(myList)</span><br><span class="line"></span><br><span class="line">    for _ in range(1000):</span><br><span class="line">        mySort = b</span><br><span class="line">        try:</span><br><span class="line">            print(next(mySort))</span><br><span class="line">        except StopIteration:</span><br><span class="line">            print(&quot;使用&quot; + mySort.__name__ + &quot; sort 排序完毕&quot;)</span><br><span class="line">            break</span><br></pre></td></tr></table></figure><p>更改mySort即可变更排序方法</p>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
            <tag> 笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>使用MySQL的流水账</title>
      <link href="/2020/02/28/%E4%BD%BF%E7%94%A8MySQL%E7%9A%84%E6%B5%81%E6%B0%B4%E8%B4%A6/"/>
      <url>/2020/02/28/%E4%BD%BF%E7%94%A8MySQL%E7%9A%84%E6%B5%81%E6%B0%B4%E8%B4%A6/</url>
      
        <content type="html"><![CDATA[<p>本文必然又臭又长，我一边踩坑一边排雷一边写。</p><a id="more"></a><h2 id="1-软件基础"><a href="#1-软件基础" class="headerlink" title="1.软件基础"></a>1.软件基础</h2><p>MySQL 5.7<br>Navicat 11<br>Wind终端</p><h2 id="2-先建立第一个表"><a href="#2-先建立第一个表" class="headerlink" title="2.先建立第一个表"></a>2.先建立第一个表</h2><h3 id="2-1-准备工作"><a href="#2-1-准备工作" class="headerlink" title="2.1.准备工作"></a>2.1.准备工作</h3><p>2019/12/10<br>今晚管理经济学期末考试。<br>但是在正式复习前，我在图书馆丧心病狂地导出将近一千万条数据——A股所有股票自上市以来每个交易日的公司总市值。<br>然后又导出了两千万条数据——A股所有股票自上市以来每个交易日的股价均价+涨跌幅。</p><p>这样选择，一方面是因为数据量真的很大很刺激；另一方面是因为这些数据基本覆盖了日常会用到的数据类型，可以测试对不同类型的使用。<br>具体来说，包括：</p><ul><li>id 整型数据 int </li><li>Stock_Code 可变字符串（数字+小数点+英文） varchar</li><li>Short_name 可变字符串（中文）varchar</li><li>Date 日期 date</li><li>Market_value 定点数 decimal(15,2)</li><li>Mean_Price 浮点数 float</li><li>Change 浮点数 float</li></ul><p><em>int最大只能到21亿左右，所以如果关系到钱的时候，并且为整数，就应该使用bigint<br>在本例中，货币很大，不过是小数，而且小数点后还有两位，可以使用decimal，设置最大位数15，小数点后2位<br>涨跌幅在导出数据时，在表头写明<code>单位%</code>了，在数据单元格中直接以浮点数存储%前面的数字；MySQL中没有专门的百分比类型，因此在其他情况下，要么把百分数转为浮点数存储，要么以字符串形式存为\</em>%形式，计算时再转化<br>MySQL中的utf8是假的，有中文的列必须选utf8mb4*</p><p>主键设置为 Stock_Code + Date<br>索引设置为 Stock_Code + Date</p><h3 id="2-2-测试导入"><a href="#2-2-测试导入" class="headerlink" title="2.2.测试导入"></a>2.2.测试导入</h3><p>测试导入选择先导入一个csv文件<br>在测试导入的时候还遇见了一件烦心事，那就是日期导入总是变成0，改了几次日期分隔符，无论是<code>/</code>还是<code>-</code>都不行，最后暴力解决，直接从csv文件中复制了日期分隔符<code>-</code>才行。<br>后来检测了一下各个符号的ASCII码，才发现真正的日期分隔符和减号并不是一样的…..<br>所以以后要导入日期的时候，日期分隔符最好从原文件复制。</p><h3 id="2-3-导入全部市值文件"><a href="#2-3-导入全部市值文件" class="headerlink" title="2.3.导入全部市值文件"></a>2.3.导入全部市值文件</h3><p>Wind导出时，我怕他崩溃，选择了每个股票生成一个单独的csv文件。<br>然后在正式导入之前我就看着这3745个文件陷入了沉思…</p><p>好吧叫出我们的好朋友Python吧</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">import os</span><br><span class="line">import pandas as pd</span><br><span class="line">from sqlalchemy import create_engine</span><br><span class="line"></span><br><span class="line">if __name__ == &apos;__main__&apos;:</span><br><span class="line">    MYSQL_USER = &apos;root&apos;</span><br><span class="line">    MYSQL_PASSWORD = &apos;password&apos;</span><br><span class="line">    MYSQL_HOST_IP = &apos;127.0.0.1&apos;</span><br><span class="line">    MYSQL_PORT = &apos;3306&apos;</span><br><span class="line">    MYSQL_DATABASE = &apos;stocks&apos;</span><br><span class="line">    engine = create_engine(</span><br><span class="line">        &apos;mysql+pymysql://&apos;</span><br><span class="line">        + MYSQL_USER</span><br><span class="line">        + &apos;:&apos;</span><br><span class="line">        + MYSQL_PASSWORD</span><br><span class="line">        + &apos;@&apos;</span><br><span class="line">        + MYSQL_HOST_IP</span><br><span class="line">        + &apos;:&apos;</span><br><span class="line">        + MYSQL_PORT</span><br><span class="line">        + &apos;/&apos;</span><br><span class="line">        + MYSQL_DATABASE,</span><br><span class="line">        echo=False</span><br><span class="line">    )</span><br><span class="line">    file_list = os.listdir(&apos;A股_市值&apos;)</span><br><span class="line">    file_list_com = [&apos;A股_市值/&apos; + i for i in file_list]</span><br><span class="line">    for i in file_list_com:</span><br><span class="line">        print(i)</span><br><span class="line">        df = pd.read_csv(i, encoding=&apos;ansi&apos;)</span><br><span class="line">        df.iloc[:, :4].to_sql(&apos;Market_Value&apos;, con=engine, if_exists=&apos;append&apos;, index=False, chunksize=500)</span><br><span class="line">        print(i)</span><br><span class="line">    print(&quot;**********************************&quot;)</span><br></pre></td></tr></table></figure><p>由于wind导出的csv格式不是很符合pandas的标准，所以添加了几个额外参数。</p><p>wind导出的数据是ansi格式，默认是以utf-8读入，所以要声明encoding<br>wind导出的数据每行结尾处还添加了一个<code>,</code>，pandas在读入的时候会认为这是新的一列数据，但是为空，所以使用了<code>iloc</code>函数限定，不选择误生成的最后一列数据。<br>pandas往MySQL写入数据时，自动认为第一行是列名，所以不会写入，因此不用专门选择从第二行开始，不然就会缺失第一行正式数据</p><p>但是在使用Python脚本自动导入csv的时候，倒是不用很专门设置时间的分隔符，这很舒服。</p><h2 id="3-第二个表"><a href="#3-第二个表" class="headerlink" title="3.第二个表"></a>3.第二个表</h2><p>2019/12/12<br>交完会计案例课的“两康”分析作业就神清气爽了。今天换一个类型的数据。</p><h3 id="3-1-准备工作"><a href="#3-1-准备工作" class="headerlink" title="3.1. 准备工作"></a>3.1. 准备工作</h3><p>来图书馆导出全部A股公司的基本信息：</p><ul><li>代码</li><li>简称</li><li>全称</li><li>成立日期</li><li>上市日期</li><li>主营业务</li><li>公司简介</li><li>所在省份</li><li>所在城市</li><li>所在县级机构</li><li>网址</li><li>审计机构</li></ul><p>今天选择了xlsx文件来测试学习。<br>其实我还下载很多列数据，这边不全部列出来，只列对拓展MySQL技术有关的列。<br>如果有很多列的时候，先建立表，然后再导入的动作中，我建立表格写表头内容都会疯。</p><p>还好Navicat中有一个导入向导的功能，直接选择xlsx文件，他会帮你根据文件中的第一行建立数据库中的表头，然后你只需要调整数据类型就好了。</p><h3 id="3-2-排雷"><a href="#3-2-排雷" class="headerlink" title="3.2. 排雷"></a>3.2. 排雷</h3><p>在第一次导入的时候遇到了两个问题：</p><ul><li>成立时间导入后为0，而上市时间正常</li><li>3700+家公司只成功导入了180家</li></ul><p>打开xlsx发现，成立时间在xlsx中显示的是<code>1993-04-29</code>形式，点击进单元格的时候是<code>1993/04/29</code>；而上市时间是<code>19930429</code>形式。<br>而Navicat在导入之前默认的日期分隔符是<code>/</code>。<br>以上说明：<br>MySQL对日期的输入格式要求不是很严格，<code>19930429</code>没有分隔符他能自动识别；但对于<code>1993-04-29</code>这种有分隔符的，他会按照设定的分隔符进行分割。<br>虽然在xlsx中编辑时看到日期分隔符是<code>/</code>形式，但实际不是，得用<code>-</code>。</p><p>后来我该用<code>-</code>做导入时候的分隔符，就成功了。<br>网上一堆乱七八糟的教程说在xlsx文件里分列、转文本等方法，简直可可爱爱。</p><p>第二个问题，猜测是公司简介、主营业务之类的，是大段文字，而我按默认设置的varchar，只是把长度改成了10000。结果证明无效。<br>于是我换为text格式，再导入，成功。<br>其中，text无需设置长度，最多可存储64k文本内容。</p><h1 id="4-联表查询"><a href="#4-联表查询" class="headerlink" title="4. 联表查询"></a>4. 联表查询</h1><p>2019/12/12<br>现在总共建了三个表，基本可以开始玩了。</p><h2 id="4-1-联表查询"><a href="#4-1-联表查询" class="headerlink" title="4.1. 联表查询"></a>4.1. 联表查询</h2><p>寻找市值过1000亿的企业所在的省份<br>首先玩联表查询。<br>Market_Value表中存储的所有上市公司自上市以来的每个交易日市值。<br>我们以市值1000亿为条件，筛选市值曾经大于过1000亿的上市公司的证券代码，并以此证券代码在Info表中查询对应的上市公司所在的省份。<br>然后统计每个省的公司数量，并降序排列</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">SELECT</span><br><span class="line">COUNT(`省份`),</span><br><span class="line">`省份`</span><br><span class="line">FROM</span><br><span class="line">info</span><br><span class="line">WHERE</span><br><span class="line">`代码` IN (</span><br><span class="line">SELECT</span><br><span class="line">`代码`</span><br><span class="line">FROM</span><br><span class="line">market_value</span><br><span class="line">WHERE</span><br><span class="line">`总市值(元)` &gt; 100000000000</span><br><span class="line">)</span><br><span class="line">GROUP BY</span><br><span class="line">`省份`</span><br><span class="line">ORDER BY</span><br><span class="line">COUNT(`省份`) DESC;</span><br></pre></td></tr></table></figure><p>上市公司市值破千亿的企业北京最多，41家。</p><h2 id="4-2-JOIN和UNION"><a href="#4-2-JOIN和UNION" class="headerlink" title="4.2. JOIN和UNION"></a>4.2. JOIN和UNION</h2><p>从Market_Value表中挑选市值破千亿的公司代码，日期，然后从Info表中配对应的公司全称，省份。<br>由于破千亿是一个持续的状态或可以多次达到的状态，正常情况会把每一次在千亿以上的数据行都列出来，所以我增加了<code>GROUP BY</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">SELECT</span><br><span class="line">market_value.`代码`,</span><br><span class="line">market_value.`总市值(元)`,</span><br><span class="line">market_value.`日期`,</span><br><span class="line">inf1.`公司中文名称`,</span><br><span class="line">inf1.`公司网站`</span><br><span class="line">FROM</span><br><span class="line">inf1</span><br><span class="line">JOIN market_value ON market_value.`代码` = inf1.`代码`</span><br><span class="line">WHERE</span><br><span class="line">market_value.`总市值(元)` &gt; 100000000000</span><br><span class="line">GROUP BY</span><br><span class="line">market_value.`代码`;</span><br></pre></td></tr></table></figure><p>在用JOIN这种两个表联合操作的函数时，一定要在每个列名前面标注表名。</p><p>union相当于在两个表中查两次，但是在同一（或多）列一起输出。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">SELECT</span><br><span class="line">market_value.`代码`</span><br><span class="line">FROM</span><br><span class="line">market_value</span><br><span class="line">WHERE</span><br><span class="line">market_value.`总市值(元)` &gt; 100000000000</span><br><span class="line">UNION</span><br><span class="line">SELECT</span><br><span class="line">inf1.`代码`</span><br><span class="line">FROM</span><br><span class="line">inf1</span><br><span class="line">WHERE</span><br><span class="line">inf1.`注册资本</span><br><span class="line">[单位] 元` &lt; 500000000</span><br><span class="line"></span><br><span class="line">GROUP BY</span><br><span class="line">`代码;</span><br></pre></td></tr></table></figure><p>输出列的名字以第一个表中列名为准，在使用GROUP BY去重的时候可以用到列名</p><h1 id="5-2020了…"><a href="#5-2020了…" class="headerlink" title="5. 2020了…"></a>5. 2020了…</h1><p>今天是2020/2/28…………<br>今天突然发现还有这么一篇博客藏在角落里……………<br>发出来吧…………</p>]]></content>
      
      
      <categories>
          
          <category> MySQL </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MySQL </tag>
            
            <tag> 笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python中有关规范的笔记</title>
      <link href="/2020/02/27/Python%E4%B8%AD%E6%9C%89%E5%85%B3%E8%A7%84%E8%8C%83%E7%9A%84%E7%AC%94%E8%AE%B0/"/>
      <url>/2020/02/27/Python%E4%B8%AD%E6%9C%89%E5%85%B3%E8%A7%84%E8%8C%83%E7%9A%84%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<blockquote><p>一会要上郭老师的课。<br>我现在慌极了。</p></blockquote><a id="more"></a><p>今天翻到的是规范。<br>表示私有的就以下划线开头。最后一列就不翻了</p><h1 id="命名规范"><a href="#命名规范" class="headerlink" title="命名规范"></a>命名规范</h1><table><thead><tr><th>Type</th><th>Public</th><th>Internal</th></tr></thead><tbody><tr><td>Modules</td><td>lower_with_under</td><td>_lower_with_under</td></tr><tr><td>Packages</td><td>lower_with_under</td><td></td></tr><tr><td>Classes</td><td>CapWords</td><td>_CapWords</td></tr><tr><td>Exceptions</td><td>CapWords</td><td></td></tr><tr><td>Functions</td><td>lower_with_under()</td><td>_lower_with_under()</td></tr><tr><td>Global/Class Constants</td><td>CAPS_WITH_UNDER</td><td>_CAPS_WITH_UNDER</td></tr><tr><td>Global/Class Variables</td><td>lower_with_under</td><td>_lower_with_under</td></tr><tr><td>Instance Variables</td><td>lower_with_under</td><td>_lower_with_under (protected) or __lower_with_under (private)</td></tr><tr><td>Method Names</td><td>lower_with_under()</td><td>_lower_with_under() (protected) or __lower_with_under() (private)</td></tr><tr><td>Function/Method Parameters</td><td>lower_with_under</td><td></td></tr><tr><td>Local Variables</td><td>lower_with_under</td><td></td></tr><tr><td>翻译一下给我自己看</td><td></td><td></td></tr><tr><td>Type</td><td>Public</td><td>Internal</td></tr><tr><td>—-</td><td>—-</td><td>—-</td></tr><tr><td>模块</td><td>小写，以下划线连接</td><td>_lower_with_under</td></tr><tr><td>包</td><td>小写，以下划线连接</td><td></td></tr><tr><td>类</td><td>首字母大写</td><td>_CapWords</td></tr><tr><td>异常</td><td>首字母大写</td><td></td></tr><tr><td>函数</td><td>小写，以下划线连接，加上()</td><td>_lower_with_under()</td></tr><tr><td>全局常量/类常量</td><td>大写，以下划线连接</td><td>_CAPS_WITH_UNDER</td></tr><tr><td>全局变量/类变量</td><td>小写，以下划线连接</td><td>_lower_with_under</td></tr><tr><td>实例变量</td><td>小写，以下划线连接</td><td>_lower_with_under (protected) or __lower_with_under (private)</td></tr><tr><td>方法名</td><td>小写，以下划线连接，加上()</td><td>_lower_with_under() (protected) or __lower_with_under() (private)</td></tr><tr><td>函数参数/方法参数</td><td>小写，以下划线连接</td><td></td></tr><tr><td>局部变量</td><td>小写，以下划线连接</td><td></td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
            <tag> 笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python中优化程序运行速度的笔记</title>
      <link href="/2020/02/23/Python%E4%B8%AD%E4%BC%98%E5%8C%96%E7%A8%8B%E5%BA%8F%E8%BF%90%E8%A1%8C%E9%80%9F%E5%BA%A6%E7%9A%84%E7%AC%94%E8%AE%B0/"/>
      <url>/2020/02/23/Python%E4%B8%AD%E4%BC%98%E5%8C%96%E7%A8%8B%E5%BA%8F%E8%BF%90%E8%A1%8C%E9%80%9F%E5%BA%A6%E7%9A%84%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<blockquote><p>日常翻一翻Python Cookbook。<br>今天抽到的是有关优化的部分。</p></blockquote><a id="more"></a><h1 id="1-优化原理"><a href="#1-优化原理" class="headerlink" title="1. 优化原理"></a>1. 优化原理</h1><p>优化运行速度的原理主要有4个：</p><ul><li>针对循环的优化更有意义</li><li>全局变量的检索速度更快</li><li>属性访问（通过<code>.</code>的方式访问）速度会更慢</li><li>Python自带的数据结构是基于C编写的，速度更快</li></ul><h1 id="2-利用局部变量"><a href="#2-利用局部变量" class="headerlink" title="2. 利用局部变量"></a>2. 利用局部变量</h1><ul><li>尽量通过自定义函数的方法，减少main函数中的逻辑处理，因为在自定义函数中的定义的变量是局部变量</li></ul><h1 id="3-减少属性访问"><a href="#3-减少属性访问" class="headerlink" title="3. 减少属性访问"></a>3. 减少属性访问</h1><ul><li><code>from threading import Thread</code>然后直接使用<code>Thread</code>，比<code>import threading</code>然后在程序中多次使用<code>threading.Thread</code>会快很多</li><li>终极必杀技：把属性访问的返回值赋给局部变量<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">import math</span><br><span class="line">def MySqrt():</span><br><span class="line">    mySqrt = math.sqrt</span><br><span class="line">    for i in range(100000):</span><br><span class="line">        print(mySqrt(i))</span><br></pre></td></tr></table></figure>就能比下面的代码快上不少<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">import math</span><br><span class="line"></span><br><span class="line">for i in range(100000):</span><br><span class="line">    print(math.sqrt(i))</span><br></pre></td></tr></table></figure></li></ul><h1 id="4-使用内置数据结构"><a href="#4-使用内置数据结构" class="headerlink" title="4. 使用内置数据结构"></a>4. 使用内置数据结构</h1><p>Python中字符串、元组、列表、集合和字典是基于C编写的，只要你还在用Python，就不可能比C更快。<br>所以如无必要，切勿自行创建新的容器。</p><h1 id="5-忌头铁"><a href="#5-忌头铁" class="headerlink" title="5. 忌头铁"></a>5. 忌头铁</h1><p>针对循环优化。<br>从O(n**n)优化到O(nlogn)<br>比优化一个字典的定义方式，省2/3的机器时间要值钱得多。</p><h1 id="6-创建大量的简单实例时使用slots"><a href="#6-创建大量的简单实例时使用slots" class="headerlink" title="6. 创建大量的简单实例时使用slots"></a>6. 创建大量的简单实例时使用<strong>slots</strong></h1><p>在模拟或者其他情况下，可能一个基础的简单类需要创建数万乃至数百万的实例，这时候改用列表或元组以节省内存，然而这么做会使程序丧失易读性。<br>比如<code>person.name</code>就比<code>person[0]</code>看起来直观些。</p><p>这时候可以使用<code>__slots__</code>定义这个类。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">class Person:</span><br><span class="line">    __slots__=[&apos;name&apos;, &apos;age&apos;, &apos;adress&apos;]</span><br><span class="line">    def __init__(self, name, age, adress):</span><br><span class="line">        self.name = name</span><br><span class="line">        self.age = age</span><br><span class="line">        self.adress = adress</span><br></pre></td></tr></table></figure><p>这种方法大概只要普通创建实例所需内存的1/3，但没法添加新属性，也没法多继承。<br>所以如果需要创建大量简单实例，用<code>__slots__</code></p>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
            <tag> 笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python中使用线程的笔记</title>
      <link href="/2020/02/21/Python%E4%B8%AD%E4%BD%BF%E7%94%A8%E7%BA%BF%E7%A8%8B%E7%9A%84%E7%AC%94%E8%AE%B0/"/>
      <url>/2020/02/21/Python%E4%B8%AD%E4%BD%BF%E7%94%A8%E7%BA%BF%E7%A8%8B%E7%9A%84%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<blockquote><p>Python的多线程还是蛮好用的。<br>翻开以前写的有用到线程的代码居然看不懂了…可能那会撸的代码不太规范。今晚重学一次。</p></blockquote><a id="more"></a><h1 id="1-创建线程"><a href="#1-创建线程" class="headerlink" title="1. 创建线程"></a>1. 创建线程</h1><p>先 import threading</p><p>有两种方法。<br>我今晚采用的是第二种。<br>第一种新建一个类，继承Thread。<br>第二种正常新建一个函数。然后用如下方式：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">def print_1(waitTime):</span><br><span class="line">    n = 0</span><br><span class="line">    while True:</span><br><span class="line">        print(n)</span><br><span class="line">        n += 1</span><br><span class="line">        time.sleep(waitTime)</span><br><span class="line"></span><br><span class="line">thread1 = threading.Thread(target=print_1, args=(1,), name=&quot;t1&quot;)</span><br><span class="line">thread1.start()</span><br></pre></td></tr></table></figure><p>在<code>target</code>处不能直接给函数传递参数，必须用<code>args</code>，而且<code>args</code>的括号中，以<code>,</code>结尾。否则会直接执行print_1，影响其他线程运行。</p><h1 id="2-join"><a href="#2-join" class="headerlink" title="2. join"></a>2. join</h1><p>创建了两个线程，要求希望在运行完两个线程后，再执行下一步操作，比如print(“all done”)。<br>但若只用上述的方法，会立刻运行print(“all done”)，因为main是主线程，自己创建的线程是独立于这个线程运行的。<br>为此可以使用.join()的功能。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">thread1.start()</span><br><span class="line">thread2.start()</span><br><span class="line"></span><br><span class="line">thread1.join()</span><br><span class="line">thread2.join()</span><br><span class="line"></span><br><span class="line">print(&quot;all done&quot;)</span><br></pre></td></tr></table></figure><p>这样就能真的在完成所有工作后打印all done</p><h1 id="3-queue"><a href="#3-queue" class="headerlink" title="3. queue"></a>3. queue</h1><p>两个线程之间进行通信，可以使用global声明变量。<br>但现在推荐使用queue。</p><p>比如一个线程产生数据，另一个线程实时处理数据。<br>在爬虫中，一个线程用于根据网址获取内容，另一个线程用于处理这些获取的数据，即需要线程间通信。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">def getHtmlText(out_q):</span><br><span class="line">    ...</span><br><span class="line">    out_q.put(data, timeout=10)</span><br><span class="line"></span><br><span class="line">def parseHtmlText(in_q)</span><br><span class="line">    data = out_q.get(timeout=10)</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">myQueue = Queue()</span><br><span class="line"></span><br><span class="line">thread1 = Thread(target=getHtmlText, args=(myQueue,), name=&quot;t1&quot;)</span><br><span class="line">thread2 = Thread(target=parseHtmlText, args=(myQueue,), name=&quot;t2&quot;)</span><br><span class="line"></span><br><span class="line">thread1.start()</span><br><span class="line">thread2.start()</span><br><span class="line"></span><br><span class="line">thread1.join()</span><br><span class="line">thread2.join()</span><br><span class="line"></span><br><span class="line">print(&quot;all done&quot;)</span><br></pre></td></tr></table></figure><p>相较于使用global，Queue本身就是搭配多线程使用的，因此自带锁机制，而且可以设置阻塞时间（若没设置阻塞时间，将一直阻塞）。从而可以避免多线程中数据操作的混乱。</p><p>否则，若是没额外搭配线程的锁机制，那么比如两个线程，一个是写入111111，另一个是写入222222，你以为他最终结果是111111222222或者222222111111，但实际上很可能是12221112212这样的乱码。</p><p>建议搭配栈等数据结构使用Queue。</p><h1 id="4-Lock"><a href="#4-Lock" class="headerlink" title="4. Lock"></a>4. Lock</h1><p>如果只是进行线程间的通信，那么Queue可以很好的解决。<br>但若还要进行IO打印之类的对外界通信，那么Queue可能就没办法了，这时候还是要请出线程的锁。</p><p>比如这样一段代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">def print_time():</span><br><span class="line">    while True:</span><br><span class="line">        timeNow = time.localtime(time.time())</span><br><span class="line">        print(timeNow)</span><br><span class="line">        print(&quot;--------------------&quot;)</span><br><span class="line">        print(&quot;--------------------&quot;)</span><br><span class="line">        print(&quot;--------------------&quot;)</span><br><span class="line">    </span><br><span class="line">thread3 = threading.Thread(target=print_time, name=&quot;t3&quot;)</span><br><span class="line">thread4 = threading.Thread(target=print_time, name=&quot;t4&quot;)</span><br><span class="line">thread5 = threading.Thread(target=print_time, name=&quot;t5&quot;)</span><br><span class="line">thread3.start()</span><br><span class="line">thread4.start()</span><br><span class="line">thread5.start()</span><br></pre></td></tr></table></figure><p>运行正常的结果应该是输出一行时间后，跟着三行虚线，但实际运行起来可能就乱七八糟了。<br>这时候请出我们的锁。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">def print_time():</span><br><span class="line">    while True:</span><br><span class="line">        timeNow = time.localtime(time.time())</span><br><span class="line">        with myLock:</span><br><span class="line">            print(timeNow)</span><br><span class="line">            print(&quot;--------------------&quot;)</span><br><span class="line">            print(&quot;--------------------&quot;)</span><br><span class="line">            print(&quot;--------------------&quot;)</span><br><span class="line"></span><br><span class="line">myLock = threading.Lock()</span><br><span class="line">thread3 = threading.Thread(target=print_time, name=&quot;t3&quot;)</span><br><span class="line">thread4 = threading.Thread(target=print_time, name=&quot;t4&quot;)</span><br><span class="line">thread5 = threading.Thread(target=print_time, name=&quot;t5&quot;)</span><br><span class="line">thread3.start()</span><br><span class="line">thread4.start()</span><br><span class="line">thread5.start()</span><br></pre></td></tr></table></figure><p>这时，打印出来的就是每一行时间都跟着三条虚线了。<br>注意，必须所有线程公用一个锁，所以要提前创建一个锁。并且不用声明myLock为global，因为在这里，我们不对myLock进行修改。</p>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
            <tag> 笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python中使用迭代器的笔记</title>
      <link href="/2020/02/20/Python%E4%B8%AD%E4%BD%BF%E7%94%A8%E8%BF%AD%E4%BB%A3%E5%99%A8%E7%9A%84%E7%AC%94%E8%AE%B0/"/>
      <url>/2020/02/20/Python%E4%B8%AD%E4%BD%BF%E7%94%A8%E8%BF%AD%E4%BB%A3%E5%99%A8%E7%9A%84%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<blockquote><p>今晚在看生成器，貌似在多次循环中可以节省内存。</p></blockquote><a id="more"></a><h1 id="1-构造方法"><a href="#1-构造方法" class="headerlink" title="1. 构造方法"></a>1. 构造方法</h1><p>将原本该返回list的，改为返回单个元素，<br>并在构造函数的时候，将<code>return</code>换为<code>yield</code>。</p><p>若需要生成有限个，在构造函数的时候使用如下方法</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">n = 0</span><br><span class="line">while n &lt; max_value:</span><br><span class="line">    yield n</span><br><span class="line">    n += 1</span><br></pre></td></tr></table></figure><p>若需要生成无限个，在构造函数的时候使用如下方法</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">n = 0</span><br><span class="line">while True:</span><br><span class="line">    yield n</span><br><span class="line">    n += 1</span><br></pre></td></tr></table></figure><h1 id="2-原理"><a href="#2-原理" class="headerlink" title="2. 原理"></a>2. 原理</h1><p>与普通的直接完整生成一个List不同，含yield的函数访问一次只生成一个元素并返回。<br>构造的生成器函数内有循环，每次访问，运行到yield所在的行后即停止。</p><h1 id="3-使用方法"><a href="#3-使用方法" class="headerlink" title="3. 使用方法"></a>3. 使用方法</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">for i in gen(5):</span><br><span class="line">    print(i)</span><br><span class="line"></span><br><span class="line"># 输出结果</span><br><span class="line">0</span><br><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td></tr></table></figure><p>或</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">myGen = gen(5)</span><br><span class="line">next(myGen)</span><br><span class="line">next(myGen)</span><br><span class="line">next(myGen)</span><br><span class="line">next(myGen)</span><br><span class="line">next(myGen)</span><br><span class="line"># 输出结果</span><br><span class="line">0</span><br><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td></tr></table></figure><h1 id="4-注意"><a href="#4-注意" class="headerlink" title="4. 注意"></a>4. 注意</h1><ul><li><p>有的地方在教生成器的时候，还在用<code>myGen.next()</code>的方法，在新版Python中已换为函数式<code>next(myGen)</code></p></li><li><p>老教材中说，常用用的<code>for i in range(value)</code>，若value值比较大，可能会造成内存浪费，推荐使用生成器xrange的方法，但在新版Python中，已经没有xrange了，xrange的特性已经集成到range中了，也就是说range(10)和range(10000)都不会造成内存浪费</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
            <tag> 笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>使用Java编写仿真程序的学习笔记-1</title>
      <link href="/2020/02/09/%E4%BD%BF%E7%94%A8Java%E7%BC%96%E5%86%99%E4%BB%BF%E7%9C%9F%E7%A8%8B%E5%BA%8F%E7%9A%84%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
      <url>/2020/02/09/%E4%BD%BF%E7%94%A8Java%E7%BC%96%E5%86%99%E4%BB%BF%E7%9C%9F%E7%A8%8B%E5%BA%8F%E7%9A%84%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<blockquote><p>在B站看到一个视频<a href="https://www.bilibili.com/video/av86478875/" target="_blank" rel="noopener">《计算机仿真程序告诉你为什么现在还没到出门的时候！！！》</a>。<br>使用Java编写仿真程序，模拟疫情传播。<br>学习了许多，做个笔记。</p></blockquote><a id="more"></a><p>源码也已经在Github发布，有兴趣的戳<a href="https://github.com/KikiLetGo/VirusBroadcast" target="_blank" rel="noopener">这里</a>clone。</p><h1 id="1-getInstance"><a href="#1-getInstance" class="headerlink" title="1. getInstance"></a>1. getInstance</h1><p>Java中，一般使用<code>new + 类</code>的方法创建对象。这种可以创建任意数量的对象，且各自独立。</p><p>但在Java仿真模拟中，如果多个class，即多个java程序需要对同一个对象（本例中是全部的Person对象组成的PersonPool这个对象）进行多次操作，可以使用getInstance的方法得到这个唯一恒定对象。</p><p>该方法优点及使用场景：</p><ul><li>全部程序使用同一个对象，避免操作对象选择错误</li><li>对象的定义过程在类的定义过程确定，仿真过程的定义和使用过程完全独立</li><li>基础对象的定义过程，可以与“该对象组合形成的新对象”进行交互（即在定义<code>人</code>的时候，可以定义<code>人</code>与<code>社会</code>进行交互的操作）</li><li>使用场景：仿真程序中，个体形成的整体，可以使用</li></ul><h1 id="2-Constants程序"><a href="#2-Constants程序" class="headerlink" title="2. Constants程序"></a>2. Constants程序</h1><p>该程序没有定义任何操作，只定义了常数。<br>该方法优点：</p><ul><li>可以把与模拟有关的常量提取出来，其他程序使用的时候使用Constants.常量名的方法访问</li><li>验证不同常量对仿真结果的影响时，便于修改常量</li></ul><h1 id="3-可视化"><a href="#3-可视化" class="headerlink" title="3. 可视化"></a>3. 可视化</h1><p>main文件中：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">var p = new MyPanel();</span><br><span class="line">var panelThread = new Thread(p);</span><br><span class="line">var frame = new JFrame(&quot;疫情模拟&quot;);</span><br><span class="line"></span><br><span class="line">frame.add(p);</span><br><span class="line">frame.setSize(1000, 800);</span><br><span class="line">frame.setLocationRelativeTo(null);</span><br><span class="line">frame.setVisible(true);</span><br><span class="line">frame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);</span><br><span class="line">panelThread.start();</span><br></pre></td></tr></table></figure><p>这样可以以windows视窗的形式展示仿真过程及结果。</p><p>MyPanel文件中：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">public class MyPanel extends JPanel implements Runnable</span><br></pre></td></tr></table></figure><p>MyPanel继承自JPanel父类及Runnable的接口。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public MyPanel() &#123;</span><br><span class="line">    this.setBackground(new Color(0x444444));</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>设置窗口背景颜色。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">    public void run() &#123;</span><br><span class="line">        while (true) &#123;</span><br><span class="line">            this.repaint();</span><br><span class="line"></span><br><span class="line">            try &#123;</span><br><span class="line">                Thread.sleep(100);</span><br><span class="line">                System.out.println(worldTime);</span><br><span class="line">                worldTime++;</span><br><span class="line">            &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>设置窗口更新，worldTime是本次仿真中代表时间流逝的变量，一般仿真都会用到。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">    public void paint(Graphics arg0) &#123;</span><br><span class="line">        super.paint(arg0);</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>可以理解为，窗口显示的每一帧，显示什么内容。<br>使用<code>arg0.</code>的方法，为每一帧添加内容。<br>先为arg0.setColor，然后使用arg0.drawRect等功能，即可描绘内容<br>若在此操作中有使用到与时间有关的操作，建议新建一个时间参数，仅在此函数中自加，不要使用worldTime。在实践中一般难以捕捉到worldTime为特定值的时候。可能与多线程有关。</p><h1 id="4-static"><a href="#4-static" class="headerlink" title="4. static"></a>4. static</h1><p>定义静止的变量或函数操作。即使没有实例化某一个类，也可以直接通过<code>类名.变量</code>的方法访问。<br>不同于final，final之后该变量不可改，但static可以改，只是这个变量与类共存，而不依赖于某个对象存在。</p><p>使用场景：</p><ul><li>对于一个类的所有实例，该变量总是一样，而且这个类可能会变</li></ul>]]></content>
      
      
      <categories>
          
          <category> 编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 编程 </tag>
            
            <tag> 仿真 </tag>
            
            <tag> Java </tag>
            
            <tag> 学习笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>一些你想耍流氓时，能帮你优雅一点的工具</title>
      <link href="/2019/11/30/%E4%B8%80%E4%BA%9B%E4%BD%A0%E6%83%B3%E8%80%8D%E6%B5%81%E6%B0%93%E6%97%B6%EF%BC%8C%E8%83%BD%E5%B8%AE%E4%BD%A0%E4%BC%98%E9%9B%85%E4%B8%80%E7%82%B9%E7%9A%84%E5%B7%A5%E5%85%B7/"/>
      <url>/2019/11/30/%E4%B8%80%E4%BA%9B%E4%BD%A0%E6%83%B3%E8%80%8D%E6%B5%81%E6%B0%93%E6%97%B6%EF%BC%8C%E8%83%BD%E5%B8%AE%E4%BD%A0%E4%BC%98%E9%9B%85%E4%B8%80%E7%82%B9%E7%9A%84%E5%B7%A5%E5%85%B7/</url>
      
        <content type="html"><![CDATA[<blockquote><p>工具工具工具！</p></blockquote><a id="more"></a><h2 id="新浪微热点"><a href="#新浪微热点" class="headerlink" title="新浪微热点 "></a><a href="http://www.wrd.cn/" target="_blank" rel="noopener">新浪微热点 </a></h2><p>提供全网热度<br>提供全网关键词词云</p><h2 id="极其厉害的抠图工具"><a href="#极其厉害的抠图工具" class="headerlink" title="极其厉害的抠图工具"></a><a href="https://www.remove.bg/zh" target="_blank" rel="noopener">极其厉害的抠图工具</a></h2><p>人物抠图十分好用<br>可以在线使用，也可以利用Python，使用他们的API</p>]]></content>
      
      
      <categories>
          
          <category> Help </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 工具 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据可视化-动态柱状图</title>
      <link href="/2019/11/21/%E6%95%B0%E6%8D%AE%E5%8F%AF%E8%A7%86%E5%8C%96-%E5%8A%A8%E6%80%81%E6%9F%B1%E7%8A%B6%E5%9B%BE/"/>
      <url>/2019/11/21/%E6%95%B0%E6%8D%AE%E5%8F%AF%E8%A7%86%E5%8C%96-%E5%8A%A8%E6%80%81%E6%9F%B1%E7%8A%B6%E5%9B%BE/</url>
      
        <content type="html"><![CDATA[<blockquote><p>就是可以看中国GDP噌噌噌往上涨的那种动态柱状图~</p></blockquote><a id="more"></a><p>虽然除了看房价噌噌噌往上涨，暂时也想不到能怎么玩。</p><p>但是确实很好看，那就拿来玩玩了。</p><p>特别鸣谢<a href="https://github.com/Jannchie/Historical-ranking-data-visualization-based-on-d3.js.git" target="_blank" rel="noopener">见齐</a>大佬免费开源他的框架。</p><h1 id="数据准备"><a href="#数据准备" class="headerlink" title="数据准备"></a>数据准备</h1><p>原生框架使用.csv文件，并且格式有点反人类……<br>如下：<br><img src="http://q0zymd4jt.bkt.clouddn.com/csv%E6%A0%BC%E5%BC%8F.jpg" alt=".csv文件中的规范数据格式"></p><p>不敢乱改原生框架，所以写了个小工具，利用.xlsx文件来生成规范的.csv文件。</p><p>代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">import xlrd</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def Save2Local(statistics, root, jud = 0):</span><br><span class="line">    with open(root, &apos;a&apos;, encoding=&apos;utf-8&apos;) as f:</span><br><span class="line">        if jud == 0:</span><br><span class="line">            f.write(str(statistics) + &apos;\n&apos;)</span><br><span class="line">        elif jud == 1:</span><br><span class="line">            f.write(str(statistics) + &apos;\t&apos;)</span><br><span class="line">        else:</span><br><span class="line">            f.write(str(statistics))</span><br><span class="line">        f.close()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class Formal2Csv(object):</span><br><span class="line">    def file_load(self, file_name):</span><br><span class="line">        data_col = []</span><br><span class="line">        workbook = xlrd.open_workbook(file_name)</span><br><span class="line">        table = workbook.sheets()[0]</span><br><span class="line">        for row in range(table.nrows):</span><br><span class="line">            data_col.append(table.row_values(row))</span><br><span class="line">        self.data = data_col</span><br><span class="line">        return data_col</span><br><span class="line"></span><br><span class="line">    def formalcsv(self, output_file_name):</span><br><span class="line">        date0 = self.data[0][1:]</span><br><span class="line">        title = &quot;name,type,value,date&quot;</span><br><span class="line">        Save2Local(title, output_file_name)</span><br><span class="line">        for data_line in self.data[1:]:</span><br><span class="line">            item_name = data_line[0]</span><br><span class="line">            num = 0</span><br><span class="line">            for item_data in data_line[1:]:</span><br><span class="line">                Save2Local(str(item_name) + &quot;,&quot; + &quot;&quot; + &quot;,&quot; +str(item_data) + &quot;,&quot; + str(date0[num]), output_file_name)</span><br><span class="line">                num += 1</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">if __name__ == &apos;__main__&apos;:</span><br><span class="line">    file_name = &quot;city_data.xlsx&quot;</span><br><span class="line">    output_file_name = &quot;city_data.csv&quot;</span><br><span class="line">    pre_data = Formal2Csv()</span><br><span class="line">    pre_data.file_load(file_name)</span><br><span class="line">    pre_data.formalcsv(output_file_name)</span><br></pre></td></tr></table></figure><p>原数据必须为.xlsx文件，如果是.xls就用正经的Excel另存为.xlsx，千万别手动更改后缀名，否则会造成奇奇怪怪的后果。<br>.xlsx文件中的数据格式也得存储为如下格式：</p><p><img src="http://q0zymd4jt.bkt.clouddn.com/xlsx%E6%A0%BC%E5%BC%8F.jpg" alt=".xlsx文件中的数据格式"></p><p>然后再在上面列出的代码中，修改file_name和outpur_file_name就可以了。</p><p>如果Python生成的.CSV文件中，日期是一堆奇怪的数值，那就在.xlsx，将日期的格式，由<code>日期</code>改为<code>常规</code>即可。</p><h1 id="历史数据排名可视化"><a href="#历史数据排名可视化" class="headerlink" title="历史数据排名可视化"></a>历史数据排名可视化</h1><p>首先需要下载由<a href="https://github.com/Jannchie/Historical-ranking-data-visualization-based-on-d3.js.git" target="_blank" rel="noopener">见齐</a>大佬提供的框架，也可以下载<a href="http://q0zymd4jt.bkt.clouddn.com/%E5%8E%86%E5%8F%B2%E6%95%B0%E6%8D%AE%E5%8F%AF%E8%A7%86%E5%8C%96.zip" target="_blank" rel="noopener">我</a>提供的修改过一些参数的版本（不分type，每页展示十条，内含2002-2017国内主要城市房价变化示例数据）</p><blockquote><p><strong>一句话用法</strong><br>只需打开src目录下的bargraph.html。然后点击页面中间的选择文件按钮，接着选择csv格式的数据文件，便可以看到可视化的结果。<br>对展示形式有其他要求的，可以用记事本/VS Code打开_config.js文件进行修改。</p></blockquote><h1 id="发布"><a href="#发布" class="headerlink" title="发布"></a>发布</h1><p>原框架仅支持在本地选择数据，然后现场展示，对发布的支持不是特别好。因此推荐使用录屏软件录屏后发布。</p>]]></content>
      
      
      <categories>
          
          <category> 可视化 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
            <tag> 编程 </tag>
            
            <tag> 工具 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>当你第一次打开时或许你可以看一下</title>
      <link href="/2019/11/21/%E5%BD%93%E4%BD%A0%E7%AC%AC%E4%B8%80%E6%AC%A1%E6%89%93%E5%BC%80%E6%97%B6%E6%88%96%E8%AE%B8%E4%BD%A0%E5%8F%AF%E4%BB%A5%E7%9C%8B%E4%B8%80%E4%B8%8B/"/>
      <url>/2019/11/21/%E5%BD%93%E4%BD%A0%E7%AC%AC%E4%B8%80%E6%AC%A1%E6%89%93%E5%BC%80%E6%97%B6%E6%88%96%E8%AE%B8%E4%BD%A0%E5%8F%AF%E4%BB%A5%E7%9C%8B%E4%B8%80%E4%B8%8B/</url>
      
        <content type="html"><![CDATA[<blockquote><p>希望你用电脑<br>用谷歌浏览器</p></blockquote><a id="more"></a><ul><li><p>如果你用手机打开，你可能会看不到随机乱跑的线条</p></li><li><p>如果你用Edge打开，你可能会看不到我精心画的纸飞机鼠标</p></li><li><p>如果哪天你在国内打不开了，那是腾讯云炸了；换国外IP访问，或者喊我一声</p></li><li><p>如果你要留言，希望你可以留下你的昵称</p></li><li><p>如果你要分享，每篇文章下面会有个分享按钮，也可以直接用微信打开分享</p></li><li><p>如果打开很慢，那是我优化不够，加载的插件比较多，但是我并不想继续优化</p></li><li><p>有两只皮卡丘，和一个小可爱</p></li><li><p>有一只皮卡丘会摇尾巴和动耳朵，希望你耐心等待加载</p></li></ul>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>关于爬虫的两个得力工具</title>
      <link href="/2019/11/15/%E5%85%B3%E4%BA%8E%E7%88%AC%E8%99%AB%E7%9A%84%E4%B8%A4%E4%B8%AA%E5%BE%97%E5%8A%9B%E5%B7%A5%E5%85%B7/"/>
      <url>/2019/11/15/%E5%85%B3%E4%BA%8E%E7%88%AC%E8%99%AB%E7%9A%84%E4%B8%A4%E4%B8%AA%E5%BE%97%E5%8A%9B%E5%B7%A5%E5%85%B7/</url>
      
        <content type="html"><![CDATA[<blockquote><p>今天与某在北京造超导核弹的<a href="https://camusecao.top" target="_blank" rel="noopener">小流氓</a>聊及爬虫的时候，发现他被反爬了。</p><p>我没有笑。</p><p>后来想起自己刚学爬虫的时候也曾被一些简单的反爬机制制裁过，索性就把我的祖传代码贴出来，供大家参考交流。对于初学者也可以直接复制使用。</p><p>当然我也是个初学者。</p></blockquote><a id="more"></a><h2 id="get-html-text-url"><a href="#get-html-text-url" class="headerlink" title="get_html_text(url)"></a>get_html_text(url)</h2><p>这是我每只爬虫的第一步，几行非常简单的代码，但也修修补补了好几回才成为今天最顺手的一个工具。</p><p>这也应该是我写的第一段正经工作代码，陪着我撸过无数个网页，测试了无数次。</p><p>可靠性 += 1</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">import requests</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def get_html_text(url):</span><br><span class="line">    try:</span><br><span class="line">        kv = &#123;&apos;User-Agent&apos;: &apos;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) &apos;</span><br><span class="line">                            &apos;Chrome/64.0.3282.140 Safari/537.36 Edge/17.17134&apos;&#125;</span><br><span class="line">        r = requests.get(url, headers=kv, timeout=30)</span><br><span class="line">        r.raise_for_status()</span><br><span class="line">        r.encoding = r.apparent_encoding</span><br><span class="line">        return r.text</span><br><span class="line">    except:</span><br><span class="line">        return &quot;&quot;</span><br></pre></td></tr></table></figure><h3 id="用法"><a href="#用法" class="headerlink" title="用法"></a>用法</h3><p># kv 模拟正常使用浏览器打开网页时，浏览器自动向网站服务器发送的headers，以此应对网站最基本的反爬机制</p><p># 一般来说，只要不是恶意攻击，或者点击速度过快，或者持续点击同一个页面，此方法足以因对大部分网站</p><p># timeout 30s内打不开网页即当做该网页无响应，避免爬虫程序卡在某一步</p><p># 正常打开的网页，本函数返回html</p><p># 无法打开的网页或响应超时的网页，本函数返回为空</p><p>使用时，将网址以文本形式(<em>就是用两个英文引号”括起来，并且一定要加上<code>http://</code>，平时自己使用浏览器时可以不用加，但爬虫程序并不会帮你加</em>)作为参数输入get_html_text(url)</p><h2 id="time-sleep"><a href="#time-sleep" class="headerlink" title="time.sleep()"></a>time.sleep()</h2><p>当你要爬携程、美团这两家的网站的时候，请<strong>千万千万千万</strong>用上这个函数！！！</p><p>来自一个被携程和美团双双封过的人的忠告！</p><p>哪一步都可以省，这一步千万不能省！！</p><p>否则你就会体验到，你连正常的打开美团想买个套餐都不行的滋味。</p><p>显然正经的爬虫应该在任何时候都加这一句。</p><h3 id="用法-1"><a href="#用法-1" class="headerlink" title="用法"></a>用法</h3><p>当你使用for语句时，在for循环的最后一行写上这函数，需要提前 <code>import time</code>，这是Python自带的一个库，不用另外安装。</p><p>括号内写上sleep的时间，以秒为单位。</p><h3 id="另外"><a href="#另外" class="headerlink" title="另外"></a>另外</h3><p>如果你问我，这个世界上有没有一个网站我可以全力爬取，不用sleep。</p><p>那我只能回答你，有。</p><p>如果你问我，那你可以不可以告诉我这个网站。</p><p>那我也只能回答你，可以。</p><p>如果你问我，那你为什么不告诉我。</p><p>那样我就只能告诉你了：</p><p>所有以<code>xmu.edu.cn</code>结尾的网站，你随便爬，一只不够放两只，单线程不够你就多线程，唯一能限制你的应该是vpn的速度。</p><p>不过你没事干啥要去爬这个网站呢？</p><p>还有一个网站也是不限制的，但我这边不能说。</p><p>说了我号可能就没了。</p>]]></content>
      
      
      <categories>
          
          <category> 编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
            <tag> 编程 </tag>
            
            <tag> 爬虫 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
    
    
    <entry>
      <title>Categories</title>
      <link href="/categories/index.html"/>
      <url>/categories/index.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>Something more about J.F. Chen</title>
      <link href="/about/index.html"/>
      <url>/about/index.html</url>
      
        <content type="html"><![CDATA[<ul><li><strong>洋文名：</strong> 并没有正式的英文名， 暂时JJJeff吧</li><li><strong>所在地：</strong> 福建 厦门</li><li><strong>职业：</strong> <code>前物理学院学生</code>、<code>现MPAcc学生</code></li><li><strong>喜欢的食物：</strong> 这本菜单上的全部东西</li><li><strong>常用编程语言：</strong> <code>Python</code>、<code>Matlab</code>、<code>(朋友你听过51单片机的汇编语言吗？）</code>、<code>MySQL</code>、<code>Java</code></li><li><strong>兴趣爱好：</strong> 躺着、靠着、给个桌子我也能趴着；平时wzry上上分，关注LOL；小概率隔天跑跑步，以前肯踢足球，现在没鞋了；不想学习时撸两行代码也很快乐</li><li><strong>近期计划：</strong> 求求你让我过了CPA吧</li><li><strong>想学：</strong> <code>Econometrics</code>、<code>建模</code>、<code>统计</code></li><li><strong>想做：</strong> 去成都看大熊猫、去西安看十三朝古都、去潮汕吃火锅、去内蒙古看草原，套马杆也想…</li><li><strong>想吃：</strong> <code>.+</code>（这是一个神奇的正则表达式）</li><li><strong>想说：</strong> 上分喊我、学习喊我、吃饭喊我</li></ul><p>其实我还想说：夏天这么可爱，我想请它吃个饭。如果你有空，你也可以来。</p><p>虽然现在已经到了早晨穿两件都不太够的季节了，但我说这句话的意思就是：<strong>你可以举着勺子开心地跑过来了</strong>。</p>]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>commonweal</title>
      <link href="/commonweal/index.html"/>
      <url>/commonweal/index.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>Tags</title>
      <link href="/tags/index.html"/>
      <url>/tags/index.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
    </entry>
    
    
  
</search>
